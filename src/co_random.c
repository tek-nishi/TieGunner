//
//	メルセンヌ・ツイスタ法による擬似乱数
//  (http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/mt.html)
//

#include "co_random.h"


#define N  624
#define M  397
#define MATRIX_A    0x9908b0dfUL				/* constant vector a */
#define UPPER_MASK  0x80000000UL				/* most significant w-r bits */
#define LOWER_MASK  0x7fffffffUL				/* least significant r bits */


struct sRND {
	unsigned int mt[N];								/* the array for the state vector  */
	int mti;										/* mti==N+1 means mt[N] is not initialized */
};


static struct sRND rnd[RND_CHNUM];


//==============================================================
void init_genrand(int ch, u_int s)
//--------------------------------------------------------------
// 乱数テーブルの初期化
//--------------------------------------------------------------
// in:	ch = enmRND_CH
//		s  = seed
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	struct sRND *r;

	r = &rnd[ch];
    r->mt[0] = s & 0xffffffffUL;
    for(r->mti = 1; r->mti < N; r->mti += 1)
    {
        r->mt[r->mti] = (1812433253UL * (r->mt[r->mti - 1] ^ (r->mt[r->mti - 1] >> 30)) + r->mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */

        r->mt[r->mti] &= 0xffffffffUL;
        /* for >32 bit machines */
	}
}

//==============================================================
u_int genrand_int32(int ch)
//--------------------------------------------------------------
// 32bit 符号無乱数を得る
//--------------------------------------------------------------
// in:	ch = enmRND_CH
//--------------------------------------------------------------
// out:	結果
//==============================================================
{
	struct sRND *r;
    unsigned int y;
    static unsigned int mag01[2] = { 0x0UL, MATRIX_A };
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

	r = &rnd[ch];
    if(r->mti >= N)
	{
		int kk;

		/* if init_genrand() has not been called, */
        if (r->mti == N+1)	init_genrand(ch, RANDOM_SEED);

        for(kk = 0; kk < (N - M); ++kk)
        {
            y = (r->mt[kk] & UPPER_MASK) | (r->mt[kk + 1] & LOWER_MASK);
            r->mt[kk] = r->mt[kk + M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for(; kk < (N-1); ++kk)
        {
            y = (r->mt[kk] & UPPER_MASK) | (r->mt[kk + 1] & LOWER_MASK);
            r->mt[kk] = r->mt[kk + (M - N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (r->mt[N - 1] & UPPER_MASK) | (r->mt[0] & LOWER_MASK);
        r->mt[N - 1] = r->mt[M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        r->mti = 0;
    }
    y = r->mt[r->mti];
	r->mti += 1;

	y ^= (y >> 11);
	y ^= (y << 7) & 0x9d2c5680UL;
	y ^= (y << 15) & 0xefc60000UL;
	y ^= (y >> 18);

	return y;
}

//==============================================================
REAL genrand_real1(int ch)
//--------------------------------------------------------------
// 0.0f <= r  <= 1.0f の区間の乱数を得る
//--------------------------------------------------------------
// in:	ch = enmRND_CH
//--------------------------------------------------------------
// out:	結果(0.0f <= r <= 1.0f)
//==============================================================
{
	return genrand_int32(ch) * (1.0 / 4294967295.0);
}

//==============================================================
REAL genrand_real2(int ch)
//--------------------------------------------------------------
// 0.0f <= r  < 1.0f の区間の乱数を得る
//--------------------------------------------------------------
// in:	ch = enmRND_CH
//--------------------------------------------------------------
// out:	結果(0.0f <= r < 1.0f)
//==============================================================
{
    return genrand_int32(ch) * (1.0 / 4294967296.0);
}

//==============================================================
REAL genrand_real3(int ch)
//--------------------------------------------------------------
// 0.0f < r  < 1.0f の区間の乱数を得る
//--------------------------------------------------------------
// in:	ch = enmRND_CH
//--------------------------------------------------------------
// out:	結果(0.0f <= r < 1.0f)
//==============================================================
{
	return (((double)genrand_int32(ch)) + 0.5) * (1.0 / 4294967296.0);
}

//==============================================================
void RandomInit(void)
//--------------------------------------------------------------
// 初期化
//--------------------------------------------------------------
// in:	なし
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	int i;

	for(i = 0; i < RND_CHNUM; ++i)	init_genrand(i, RANDOM_SEED);
}

