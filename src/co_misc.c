
#include "co_misc.h"


//--------------
// ライン描画用
//--------------
#define LEFT    1
#define RIGHT   2
#define TOP     4
#define BOTTOM  8


static int sin_tbl[1024];						// sin(r) 用テーブル

const FVector2 FVec2Zero = { 0.0f, 0.0f };
const FVector2 FVec2One = { 1.0f, 1.0f };
const FVector3 FVec3One = { 1.0f, 1.0f, 1.0f };
const FVector4 FVec4One = { 1.0f, 1.0f, 1.0f, 1.0f };

const sRGBA RGBAClear = {0.0f, 0.0f, 0.0f, 0.0f };
const sRGBA RGBABlack = {0.0f, 0.0f, 0.0f, 1.0f };
const sRGBA RGBAWhite = {1.0f, 1.0f, 1.0f, 1.0f };


//==============================================================
void SetRGBA(sRGBA *dst, REAL r, REAL g, REAL b, REAL a)
//--------------------------------------------------------------
// 色セット
//--------------------------------------------------------------
// in:	dst        = 出力先
//		r, g, b, a = 値
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	dst->red   = r;
	dst->green = g;
	dst->blue  = b;
	dst->alpha = a;
}

//==============================================================
void SetV2d(FVector2 *dst, REAL x, REAL y)
//--------------------------------------------------------------
// ベクトルの値をセット
//--------------------------------------------------------------
// in:	dst  = 出力先
//		x, y = 値
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	dst->x = x;
	dst->y = y;
}

//==============================================================
void AddV2d(FVector2 *dst, FVector2 *s0, FVector2 *s1)
//--------------------------------------------------------------
// ベクトルの加算
//   dst = s0 + s1
//--------------------------------------------------------------
// in:	dst    = 出力先
//		s0, s1 = 計算するベクトル
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FVector2 tmp;

	tmp.x = s0->x + s1->x;
	tmp.y = s0->y + s1->y;

	*dst = tmp;
}

//==============================================================
void SubV2d(FVector2 *dst, FVector2 *s0, FVector2 *s1)
//--------------------------------------------------------------
// ベクトルの減算
//   dst = s0 - s1
//--------------------------------------------------------------
// in:	dst    = 出力先
//		s0, s1 = 計算するベクトル
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FVector2 tmp;

	tmp.x = s0->x - s1->x;
	tmp.y = s0->y - s1->y;

	*dst = tmp;
}

//==============================================================
void CopyV2d(FVector2 *dst, FVector2 *src)
//--------------------------------------------------------------
// ベクトルのコピー
//--------------------------------------------------------------
// in:	dst = コピー先
//		src = コピー元
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	*dst = *src;
}

//==============================================================
void ScaleV2d(FVector2 *out, FVector2 *in, REAL scale)
//--------------------------------------------------------------
// ベクトルのスケーリング
//--------------------------------------------------------------
// in:	out   = 出力
//		in    = 入力
//		scale = スケール値
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FVector2 tmp;

	tmp.x = in->x * scale;
	tmp.y = in->y * scale;

	*out = tmp;
}

//==============================================================
void SetV3d(FVector3 *dst, REAL x, REAL y, REAL z)
//--------------------------------------------------------------
// ベクトルの値をセット
//--------------------------------------------------------------
// in:	dst     = 出力先
//		x, y, z = 値
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	dst->x = x;
	dst->y = y;
	dst->z = z;
}

//==============================================================
void AddV3d(FVector3 *dst, FVector3 *s0, FVector3 *s1)
//--------------------------------------------------------------
// ベクトルの加算
//   dst = s0 + s1
//--------------------------------------------------------------
// in:	dst    = 出力先
//		s0, s1 = 計算するベクトル
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FVector3 tmp;

	tmp.x = s0->x + s1->x;
	tmp.y = s0->y + s1->y;
	tmp.z = s0->z + s1->z;

	*dst = tmp;
}

//==============================================================
void SubV3d(FVector3 *dst, FVector3 *s0, FVector3 *s1)
//--------------------------------------------------------------
// ベクトルの減算
//   dst = s0 - s1
//--------------------------------------------------------------
// in:	dst    = 出力先
//		s0, s1 = 計算するベクトル
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FVector3 tmp;

	tmp.x = s0->x - s1->x;
	tmp.y = s0->y - s1->y;
	tmp.z = s0->z - s1->z;

	*dst = tmp;
}

//==============================================================
void CopyV3d(FVector3 *dst, FVector3 *src)
//--------------------------------------------------------------
// ベクトルのコピー
//--------------------------------------------------------------
// in:	dst = コピー先
//		src = コピー元
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	*dst = *src;
}

//==============================================================
void ScaleV3d(FVector3 *out, FVector3 *in, REAL scale)
//--------------------------------------------------------------
// ベクトルのスケーリング
//--------------------------------------------------------------
// in:	out   = 出力
//		in    = 入力
//		scale = スケール値
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FVector3 tmp;

	tmp.x = in->x * scale;
	tmp.y = in->y * scale;
	tmp.z = in->z * scale;

	*out = tmp;
}

//==============================================================
void SetV4d(FVector4 *dst, REAL x, REAL y, REAL z, REAL w)
//--------------------------------------------------------------
// 値をまとめて設定
//--------------------------------------------------------------
// in:	dst        = 格納先
//		x, y, z, w = 値
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	dst->x = x;
	dst->y = y;
	dst->z = z;
	dst->w = w;
}

//==============================================================
int limit(int x, int min_value, int max_value)
//--------------------------------------------------------------
// 入力値が mix〜max なら、そのまま値を返し、範囲外なら min or max を返す
//--------------------------------------------------------------
// in:	x = 入力
//		min = 最小値
//		max = 最大値
//--------------------------------------------------------------
// out:	計算結果
//==============================================================
{
	return min(max(x, min_value), max_value);
}

//==============================================================
int ceilingvalue(int a, int b)
//--------------------------------------------------------------
// 指定値で切り上げ
//   ex)  ceilingvalue(14, 8) = 16
//--------------------------------------------------------------
// in:	a = 入力
//		b = 基準値
//--------------------------------------------------------------
// out:	計算結果
//==============================================================
{
	return (a % b) ? a + b - (a % b) : a;
}

//==============================================================
int int2pow(int value)
//--------------------------------------------------------------
// 切り上げて一番近いべき乗値を求める
// ※負の値には対応していません
//--------------------------------------------------------------
// in:	value = 入力値
//--------------------------------------------------------------
// out:	結果
//==============================================================
{
	int res = 1;

	while(res < (1 << 30))
	{
		if(res >= value)
			break;
		res *= 2;
	}

	return res;
}

//==============================================================
int countBitValue(u_int value)
//--------------------------------------------------------------
// ビット数をカウントする
//--------------------------------------------------------------
// in:	value = 値
//--------------------------------------------------------------
// out:
//==============================================================
{
	int num = 0;
	int i;
	u_int mask;

	mask = 0x1;
	for(i = 0; i < ((int)sizeof(u_int) * 8); ++i)
	{
		if(value & mask)
		{
			++num;
		}
		mask <<= 1;
	}


	return num;
}

/* 一番下位のビットを求める */
int getLowBitValue(u_int value)
{
	int i;
	u_int mask = 0x1;
	for(i = 0; i < ((int)sizeof(u_int) * 8); i += 1)
	{
		if(mask & value) break;
		mask <<= 1;
	}
	return i;
}
	

//==============================================================
void SinTblInit(void)
//--------------------------------------------------------------
// sin(r) のテーブル初期化
//--------------------------------------------------------------
// in:	なし
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	int i;

	for(i = 0; i < 1024; ++i)
	{
		sin_tbl[i] = (int)(sinf(PI * (REAL)i / 512.0f) * 256.0f);
	}
}

//==============================================================
int SinI(int r)
//--------------------------------------------------------------
// sin(r)を求める
//--------------------------------------------------------------
// in:	r = 入力値(0 〜 1024)
//--------------------------------------------------------------
// out:	結果(-256 〜 +256)
//==============================================================
{
	return sin_tbl[r & (1024 - 1)];
}

//==============================================================
int CosI(int r)
//--------------------------------------------------------------
// cos(r)を求める
//--------------------------------------------------------------
// in:	r = 入力値(0 〜 1024)
//--------------------------------------------------------------
// out:	結果(-256 〜 +256)
//==============================================================
{
	return sin_tbl[(r + 256) & (1024 - 1)];
}

//==============================================================
void MakeWinFileName(char *dst, char *src)
//--------------------------------------------------------------
// ウインドウズ用のファイル名を作成
//--------------------------------------------------------------
// in:	dst = 出力用ポインタ
//		src = 入力用ポインタ
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	while(*src)
	{
		if(*src == '/')
		{
			*dst = '\\';
			src += 1;
			dst += 1;
		}
		else
		{
			*dst = *src;
			src += 1;
			dst += 1;
		}
	}
	*dst = '\0';
}

//==============================================================
BOOL MathIsRange(REAL val, REAL val1, REAL val2)
//--------------------------------------------------------------
// 値が一定範囲内か判定
// val1 <= val < val2 || val2 <= val < val1
//--------------------------------------------------------------
// in:	val        = 値
//		val1, val2 = 範囲
//--------------------------------------------------------------
// out:	TRUE = 内包する
//==============================================================
{
	return ((val1 <= val) && (val < val2)) || ((val2 <= val) && (val < val1));
}

//==============================================================
BOOL MathBoxCrossPoint(int x, int y, sBox *box)
//--------------------------------------------------------------
// 点とボックスの内包判定
// ※線上は含むと判定
//--------------------------------------------------------------
// in:	x, y = 点の位置
//		box  = 判定するボックス
//--------------------------------------------------------------
// out:	TRUE = 内包する
//==============================================================
{
	return ((x >= box->inf.x) && (x <= box->sup.x) && (y >= box->inf.y) && (y <= box->sup.y));
}

//==============================================================
BOOL MathPolygonCrossPoint(REAL x, REAL y, FVector2 *vtx)
//--------------------------------------------------------------
// 点と多角形の内包判定
// ※線上は含むと判定
//--------------------------------------------------------------
// in:	x, y = 点の位置
//		vtx  = 判定するポリゴン(4 頂点)
//--------------------------------------------------------------
// out:	TRUE = 内包する
//==============================================================
{
	BOOL res = FALSE;
	FVector2 pos;
	int i;

	// 一番右端の頂点を探す
	//----------------------
	pos = *vtx;
	for(i = 1; i < 4; ++i)
	{
		if(pos.x < (vtx + i)->x)	pos = *(vtx + i);
	}

	//------------------------------------------------
	// 各辺との交差判定を調べ、奇数なら内包すると判定
	// FIXME: 若干アバウトです
	//------------------------------------------------
	if(x <= pos.x)
	{
		sLine line;
		int cross = 0;

		line.start.x = x;
		line.start.y = y;
		line.end.x = pos.x + 1;
		line.end.y = y;
		for(i = 0; i < 4; ++i)
		{
			sLine chk;

			chk.start.x = (vtx + i)->x;
			chk.start.y = (vtx + i)->y;
			chk.end.x = (vtx + ((i + 1) % 4))->x;
			chk.end.y = (vtx + ((i + 1) % 4))->y;

			if(MathCheckCrossLine(&line, &chk))
			{
				// 頂点上との交差を考慮する
				if(MathIsRange(line.start.y, chk.start.y, chk.end.y))	++cross;
			}
		}
		if(cross & 0x1)		res = TRUE;
	}

	return res;
}

//==============================================================
BOOL MathBoxCrossLine(sLine *line, sBox *box)
//--------------------------------------------------------------
// 線とボックスの内包判定
// ※線上は含むと判定
//--------------------------------------------------------------
// in:	line = 線分
//		box  = 判定するボックス
//--------------------------------------------------------------
// out:	TRUE = 内包する
//==============================================================
{
	sLine b_line;
	BOOL res;

	b_line.start = box->inf;
	b_line.end.x = box->sup.x;
	b_line.end.y = box->inf.y;
	res = MathCheckCrossLine(line, &b_line);
	if(!res)
	{
		b_line.end.x = box->inf.x;
		b_line.end.y = box->sup.y;
		res = MathCheckCrossLine(line, &b_line);
		if(!res)
		{
			b_line.end = box->sup;
			b_line.start.x = box->inf.x;
			b_line.start.y = box->sup.y;
			res = MathCheckCrossLine(line, &b_line);
			if(!res)
			{
				b_line.start.x = box->sup.x;
				b_line.start.y = box->inf.y;
				res = MathCheckCrossLine(line, &b_line);
				if(!res)
				{
					res = MathBoxCrossPoint(line->start.x, line->start.y, box);
					if(!res)
						res = MathBoxCrossPoint(line->end.x, line->end.y, box);
				}
			}
		}
	}

	return res;
}

//==============================================================
BOOL MathBoxCrossBox(sBox *box1, sBox *box2)
//--------------------------------------------------------------
// ２つのボックスの交差判定
//--------------------------------------------------------------
// in:	box1, box2 = 判定するボックス
//--------------------------------------------------------------
// out:	TRUE = 交差する
//==============================================================
{
	return ((box1->sup.x >= box2->inf.x) && (box1->inf.x <= box2->sup.x) && (box1->sup.y >= box2->inf.y) && (box1->inf.y <= box2->sup.y));
}

//==============================================================
BOOL MathCheckCrossLine(sLine *l1, sLine *l2)
//--------------------------------------------------------------
// 線分の交差判定
// ※平行線は交差しないと判定する
//--------------------------------------------------------------
// in:	p1, p2 = 線分Ａ
//		p3, p4 = 線分Ｂ
//--------------------------------------------------------------
// out:	TRUE = 交差する
//==============================================================
{
	REAL val;

	if(l1->start.x >= l1->end.x)
	{
		if(((l1->start.x < l2->start.x) && (l1->start.x < l2->end.x)) || ((l1->end.x > l2->start.x) && (l1->end.x > l2->end.x)))
		{
			return FALSE;
		}
	}
    else
	{
		if(((l1->end.x < l2->start.x) && (l1->end.x < l2->end.x)) || ((l1->start.x > l2->start.x) && (l1->start.x > l2->end.x)))
		{
			return FALSE;
		}
	}
	if(l1->start.y >= l1->end.y)
	{
		if(((l1->start.y < l2->start.y) && (l1->start.y < l2->end.y)) || ((l1->end.y > l2->start.y) && (l1->end.y > l2->end.y)))
		{
			return FALSE;
		}
	}
	else
	{
		if(((l1->end.y < l2->start.y) && (l1->end.y < l2->end.y)) || ((l1->start.y > l2->start.y) && (l1->start.y > l2->end.y)))
		{
			return FALSE;
		}
	}

	val = (REAL)((l1->start.x - l1->end.x) * (l2->start.y - l1->start.y) + (l1->start.y - l1->end.y) * (l1->start.x - l2->start.x)) * (REAL)((l1->start.x - l1->end.x) * (l2->end.y - l1->start.y) + (l1->start.y - l1->end.y) * (l1->start.x - l2->end.x));
	if(val > 0.0f)
	{
		return FALSE;
	}
	val = (REAL)((l2->start.x - l2->end.x) * (l1->start.y - l2->start.y) + (l2->start.y - l2->end.y) * (l2->start.x - l1->start.x)) * (REAL)((l2->start.x - l2->end.x) * (l1->end.y - l2->start.y) + (l2->start.y - l2->end.y) * (l2->start.x - l1->end.x));
	if(val > 0.0f)
	{
		return FALSE;
	}

	return TRUE;
}

//==============================================================
BOOL MathCrossLine(IVector2 *res, sLine *line1, sLine *line2)
//--------------------------------------------------------------
// ２直線の交点を求める
//--------------------------------------------------------------
// in:	res          = 結果を格納する構造体
//		line1, line2 = 交差を調べる直線
//--------------------------------------------------------------
// out:	TRUE = 交差する
//==============================================================
{
	int a1, a2, b1, b2, c1, c2;
	int d;

	a1 = line1->end.y - line1->start.y;			// 直線の方程式(ax + by + c = 0)でのパラメータを求める
	b1 = line1->start.x - line1->end.x;
	c1 = -a1 * line1->start.x - b1 * line1->start.y;

	a2 = line2->end.y - line2->start.y;
	b2 = line2->start.x - line2->end.x;
	c2 = -a2 * line2->start.x - b2 * line2->start.y;

	d = b1 * a2 - b2 * a1;

	if(!d)
		return FALSE;							// 平行

	res->x = (c1 * b2 - c2 * b1) / d;			// 交点を計算
	res->y = (a1 * c2 - a2 * c1) / d;

	return TRUE;
}

//==============================================================
REAL MathDistancePointLine(IVector2 *pos, sLine *line)
//--------------------------------------------------------------
// 点と線分の距離を求める
// TODO: 平行四辺形に見立て、(外積 / 線分の長さ) で求める方法もある	
//--------------------------------------------------------------
// in:	pos   = 点
//		line1 = 直線
//--------------------------------------------------------------
// out:	距離(-1.0 = エラー)
//==============================================================
{
	FVector2 v1;
	FVector2 v2;
	FVector2 v3;
	FVector2 vec;
	REAL t;

	// ベクトルAB
	v1.x = (REAL)(line->end.x - line->start.x);
	v1.y = (REAL)(line->end.y - line->start.y);

	// ベクトルAP
	v2.x = (REAL)(pos->x - line->start.x);
	v2.y = (REAL)(pos->y - line->start.y);

	t = MathGetDotProduct(&v1, &v2) / (v1.x * v1.x + v1.y * v1.y);
	if((t < 0.0f) || (t > 1.0f))
	{
		// 点と直線の垂線が線分上に無ければエラー
		return -1.0f;
	}

	// ベクトルAQ
	v3.x = v1.x * t;
	v3.y = v1.y * t;

	// ベクトルQP
	vec.x = v3.x - v2.x;
	vec.y = v3.y - v2.y;

	return MathLength(&vec);
}

//==============================================================
void MathRotateXY(FVector2 *pos, REAL angle)
//--------------------------------------------------------------
// 座標の回転
//--------------------------------------------------------------
// in:	pos   = 回転する座標(ラジアン)
//		angle = 角度
//--------------------------------------------------------------
// out:	TRUE = 交差する
//==============================================================
{
	REAL sinT, cosT;
	REAL x, y;

	sinT = sinf(angle);
	cosT = cosf(angle);

	x = pos->x;
	y = pos->y;

	pos->x = (REAL)(x * cosT - y * sinT);
	pos->y = (REAL)(x * sinT + y * cosT);
}

//==============================================================
REAL MathDistance(FVector2 *_x, FVector2 *_y)
//--------------------------------------------------------------
// ２点間の距離
//--------------------------------------------------------------
// in:	_x = ベクトル 1
//		_y = ベクトル 2
//--------------------------------------------------------------
// out:	計算結果
//==============================================================
{
	REAL x;
	REAL y;

	x = _x->x - _y->x;
	y = _x->y - _y->y;

	return (REAL)sqrtf(x * x + y * y);
}

//==============================================================
BOOL MathNormalize(FVector2 *res, FVector2 *vct)
//--------------------------------------------------------------
// 単位ベクトルを求める
//--------------------------------------------------------------
// in:	res = 結果を格納するポインタ
//		vct = 計算元
//--------------------------------------------------------------
// out:	FALSE = エラー
//==============================================================
{
	REAL a;
	BOOL result = FALSE;
	FVector2 v;

	a = (REAL)sqrtf(vct->x * vct->x + vct->y * vct->y);
	if(a > 0.0f)
	{
		v.x = vct->x / a;
		v.y = vct->y / a;

		result = TRUE;
	}
	else
	{
		v.x = 0.0f;
		v.y = 0.0f;
	}
	*res = v;

	return result;
}

//==============================================================
void MathScalar(FVector2 *vct, REAL scale)
//--------------------------------------------------------------
// ベクトルをスカラ倍する
//--------------------------------------------------------------
// in:	vct   = ベクトル
//		scale = スカラ値
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	vct->x *= scale;
	vct->y *= scale;
}

//==============================================================
REAL MathLength(FVector2 *vct)
//--------------------------------------------------------------
// ベクトルのスカラ値を求める
//--------------------------------------------------------------
// in:	vct = ベクトル
//--------------------------------------------------------------
// out:	スカラ値
//==============================================================
{
	return (REAL)sqrtf(vct->x * vct->x + vct->y * vct->y);
}

//==============================================================
REAL MathGetDotProduct(FVector2 *v1, FVector2 *v2)
//--------------------------------------------------------------
// 内積を求める
//--------------------------------------------------------------
// in:	v1 = ベクトル1
//		v2 = ベクトル2
//--------------------------------------------------------------
// out:	計算結果
//==============================================================
{
	return v1->x * v2->x + v1->y * v2->y;
}

//==============================================================
void MathGetLineNormal(FVector2 *res, FVector2 *v1, FVector2 *v2)
//--------------------------------------------------------------
// 線分の法線ベクトルを求める
//--------------------------------------------------------------
// in:	res = 結果を格納するポインタ
//		v1  = ベクトル 1
//		v2  = ベクトル 2
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FVector2 vct;

	vct.x = v1->x - v2->x;
	vct.y = v1->y - v2->y;
	MathNormalize(&vct, &vct);

	res->x = vct.y;
	res->y = -vct.x;
}

//==============================================================
REAL MathVctAngle(FVector2 *v1, FVector2 *v2)
//--------------------------------------------------------------
// ベクトル同士の角度を求める
//--------------------------------------------------------------
// in:	v1, v2 = 角度を求めるベクトル
//--------------------------------------------------------------
// out:	角度(0 〜 PI)
//==============================================================
{
	REAL value, angle;
	REAL l1, l2;

	l1 = MathLength(v1);
	l2 = MathLength(v2);

	if((l1 <= 0.0f) || (l2 <= 0.0f))
	{
		// どちらかのベクトルの長さがゼロの場合、角度は０とする
		//------------------------------------------------------
		return 0.0f;
	}

	value = MathGetDotProduct(v1, v2) / (l1 * l2);
	if(value >= 1.0f)
		angle = 0.0f;
	else
		angle = (REAL)acosf(value);

	return angle;
}

//==============================================================
REAL MathVctAngleY(FVector2 *v1)
//--------------------------------------------------------------
// ベクトル(0.0, -1.0)と任意ベクトルとの角度を求める
//--------------------------------------------------------------
// in:	v1 = 角度を求めるベクトル
//--------------------------------------------------------------
// out:	角度(-PI 〜 PI)
//==============================================================
{
	FVector2 v2;
	REAL r;

	v2.x = 0.0f;
	v2.y = -1.0f;
	r = MathVctAngle(v1, &v2);
	if(v1->x < 0.0f)
		r = -r;

	return r;
}

//==============================================================
REAL MathVctAngleX(FVector2 *v1)
//--------------------------------------------------------------
// ベクトル(1.0, 0.0)と任意ベクトルとの角度を求める
//--------------------------------------------------------------
// in:	v1 = 角度を求めるベクトル
//--------------------------------------------------------------
// out:	角度(-PI 〜 PI)
//==============================================================
{
	FVector2 v2;
	REAL r;

	v2.x = 1.0f;
	v2.y = 0.0f;
	r = MathVctAngle(v1, &v2);
	if(v1->y < 0.0f)
		r = -r;

	return r;
}

//==============================================================
void MathCalcVector(FVector2 *vec, REAL angle, REAL length)
//--------------------------------------------------------------
// 指定角度方向のベクトル計算
//--------------------------------------------------------------
// in:	vec    = 結果を格納するポインタ
//		angle  = 角度(ラジアン)
//		length = 長さ
//--------------------------------------------------------------
// out:	角度(-PI 〜 PI)
//==============================================================
{
	vec->x = (REAL)(sinf(angle) * length);
	vec->y = (REAL)(-cosf(angle) * length);
}

// 角度を−πから＋πの間に正規化
REAL NormalAngle(REAL ang)
{
	if (ang < 0.0f)	return (REAL)(fmodf(ang - PI, PI * 2.0f) + PI);
	else			return (REAL)(fmodf(ang + PI, PI * 2.0f) - PI);
}

// ２つの角の差を求める
REAL DifAngle(REAL a, REAL b)
{
	return NormalAngle(a - b);
}

// 角度を−180度から＋180度の間に正規化 (DEGREE)
REAL NormalAngleDeg(REAL ang)
{
	if (ang < 0.0f)	return (REAL)(fmodf(ang - 180.0f, 360.0f) + 180.0f);
	else			return (REAL)(fmodf(ang + 180.0f, 360.0f) - 180.0f);
}

// ２つの角の差を求める(DEGREE)
REAL DifAngleDeg(REAL a, REAL b)
{
	return NormalAngleDeg(a - b);
}

//==============================================================
void MathSupershapes(FVector2 *res, REAL m, REAL n1, REAL n2, REAL n3, REAL phi)
//--------------------------------------------------------------
// パラメータによる曲線生成
//--------------------------------------------------------------
// in:	res = 結果を格納するポインタ
//		m   = 頂点数(分割数)
//		n1  = 係数1
//		n2  = 係数2
//		n3  = 係数3
//		phi = 角度(ラジアン)
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	REAL r;
	REAL t1, t2;
	REAL a = 1.0f, b = 1.0f;

	t1 = (REAL)cosf(m * phi / 4.0f) / a;
	t1 = (REAL)fabsf(t1);
	t1 = (REAL)powf(t1,n2);

	t2 = (REAL)sinf(m * phi / 4.0f) / b;
	t2 = (REAL)fabsf(t2);
	t2 = (REAL)powf(t2,n3);

	r = (REAL)powf(t1+t2,1.0f/n1);
	if (fabsf(r) == 0.0f)
	{
		res->x = 0.0f;
		res->y = 0.0f;
	}
	else
	{
		r = 1.0f / r;
		res->x = r * (REAL)cosf(phi);
		res->y = r * (REAL)sinf(phi);
   }
}

//==============================================================
BOOL PatCalcUV(FVector2 *res, int pat, int tex_w, int tex_h, int pat_w, int pat_h)
//--------------------------------------------------------------
// パターン番号からUVを求める
//--------------------------------------------------------------
// in:	res = 結果を格納するポインタ
//		pat = パターン番号
//		tex_w = テクスチャ幅
//		tex_h = テクスチャ高さ
//		pat_w = 切り出す幅
//		pat_h = 切り出す高さ
//--------------------------------------------------------------
// out:	FALSE = 失敗
//==============================================================
{
	BOOL result = FALSE;
	int w;
	int h;

	w = tex_w / pat_w;
	h = tex_h / pat_h;
	if(pat < (w * h))
	{
		res->x = pat_w * (pat % w);
		res->y = pat_h * (pat / w);

		result = TRUE;
	}

	return result;
}

// 簡易接触判定
BOOL MathCrossBox(FVector2 *src, float src_radius, FVector2 *dst, float dst_radius)
{
	float x_dist = fabsf(src->x - dst->x);
	float y_dist = fabsf(src->y - dst->y);
	float dist = src_radius + dst_radius;

	return (x_dist < dist) && (y_dist < dist);
}
