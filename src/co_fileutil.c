
#include "co_fileutil.h"
#include "co_memory.h"
#include "co_strings.h"
#include "co_debug.h"

#define TMPBUF_LEN  (64*1024)					// バックアップファイルを作成する時の一時バッファサイズ

static size_t mn_read_size;


//==============================================================
const char *GetFileBaseName(const char *fname)
//--------------------------------------------------------------
// フルパスからファイル名 + 拡張子のみを検出
//--------------------------------------------------------------
// in:	fname = ファイル名
//--------------------------------------------------------------
// out:	検出された箇所へのポインタ
//==============================================================
{
	const char *p;

	p = strrchr(fname, '/');
	if(!p)	p = fname;
	else	p += 1;

	return p;
}

//==============================================================
const char *GetFileExt(const char *file)
//--------------------------------------------------------------
// ファイル名から拡張子を取得
//--------------------------------------------------------------
// in:	file = ファイル名
//--------------------------------------------------------------
// out:	検出された箇所へのポインタ(NULL = 拡張子無し)
//==============================================================
{
	const char *p;

	p = file + strlen(file);
	while(p != file)
	{
		if(*(p - 1) == '.')
		{
			break;
		}
		if(*(p - 1) == '/')
		{
			p = file;
			break;
		}

		p--;
	}

	return (p != file) ? p : NULL;
}

//==============================================================
void GetPathName(const char *fname, char *path, char *file, BOOL flag)
//--------------------------------------------------------------
// ファイル名をパスと実ファイル名に分離
//--------------------------------------------------------------
// in:	fname = ファイル名
//		path  = パスを格納するポインタ(NULL = 格納しない)
//		file  = ファイル名を格納するポインタ(NULL = 格納しない)
//		flag  = TRUE ファイル名から拡張子を外す
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	char *p;

	if(path)
	{
		strcpy(path, fname);
		p = strrchr(path, '/');
		if(p == NULL) p = path;
		*p = '\0';
	}
	else
	{
		p = (char *)strrchr(fname, '/');
	}

	if(file)
	{
		strcpy(file, p + 1);
		if(flag)
		{
			p = strchr(file, '.');				/* 拡張子は外す */
			if(p)	*p = '\0';
		}
	}
}

//==============================================================
char *GetCurPath(char *path, char *cur)
//--------------------------------------------------------------
// カレントパスを取り除いたパスを返却する
//--------------------------------------------------------------
// in:	path = パス
//		cur  = カレントパス
//--------------------------------------------------------------
// out:	取得したパス
//==============================================================
{
	char *p;

	p = path;
	if(!strncmp(p, cur, strlen(cur)))
	{
		p += strlen(cur) + 1;
	}
	return p;
}

//==============================================================
void *_MmFileLoadB(const char *file, int area)
//--------------------------------------------------------------
// malloc して読み込む
// ※ブロックタイプ
//--------------------------------------------------------------
// in:	file = ファイル名
//		area = 読み込みエリア
//--------------------------------------------------------------
// out:	読み込みアドレス
//==============================================================
{
	sFILE *fp;
	size_t len;
	void *p;

	fp = FsOpen(file);
	ASSERT(fp);
	len = FsGetSizeOrig(fp);
	p = MemMalloc(area, len, GetFileBaseName(file));
	ASSERT(p);
	FsRead(fp, p, len);
	FsClose(fp);

	mn_read_size = len;							// FIXME:実ファイルサイズを返すべきか？

//	PRINTF("File '%s' Loaded.(%d bytes)\n", file, len);

	return p;
}

//==============================================================
size_t MmFileGetSize(void)
//--------------------------------------------------------------
// MmFileLoadB() で読み込んだサイズを得る
// ※セクタサイズ
//--------------------------------------------------------------
// in:	なし
//--------------------------------------------------------------
// out:	ファイルサイズ
//==============================================================
{
	return mn_read_size;
}

//==============================================================
BOOL MmFileCheck(const char *file)
//--------------------------------------------------------------
// ファイルが存在するかチェック
//--------------------------------------------------------------
// in:	file = ファイル名
//--------------------------------------------------------------
// out:	TRUE = 存在する
//==============================================================
{
	sFILE *fp;

	fp = FsOpen(file);
	if(fp)	FsClose(fp);

	return fp ? TRUE : FALSE;
}

//==============================================================
void MmFileWriteB(const char *file, void *ptr, size_t len)
//--------------------------------------------------------------
// ファイルを書き出す
// ※ブロックタイプ
//--------------------------------------------------------------
// in:	file = ファイル名
//		ptr  = データポインタ
//		len  = データサイズ
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	sFILE *fp;

	fp = FsCreate(file);
	ASSERT(fp);
	FsWrite(fp, ptr, len);
	FsClose(fp);
}

//==============================================================
void *MmTextFileLoad(const char *file)
//--------------------------------------------------------------
// テキストファイルを読み込む
// ※データ終端に '\0' を付加します
//--------------------------------------------------------------
// in:	file = ファイル名
//--------------------------------------------------------------
// out:	読み込みアドレス
//==============================================================
{
	sFILE *fp;
	size_t len;
	char *p;

	fp = FsOpen(file);
	ASSERT(fp);
	len = FsGetSizeOrig(fp);
	p = (char *)fsMalloc(len + 1, "text data");
	ASSERT(p);
	FsRead(fp, p, len);
	FsClose(fp);

	*(p + len) = '\0';

	return p;
}

//==============================================================
void MakeBackupFile(const char *fname)
//--------------------------------------------------------------
// PATH_BACKUP にバックアップをとる
//--------------------------------------------------------------
// in:	file = バックアップを取るファイル名
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	char d_name[FNAME_MAXLEN];
	void *tmp_buf;
	sFILE *fd_src, *fd_dst;
	size_t len, size;

	// オリジナルのファイルを開く
	//----------------------------
	fd_src = FsOpen(fname);
	if(!fd_src)
	{
		return;
	}

	// バックアップファイルの作成
	//----------------------------
	sprintf(d_name, PATH_BACKUP"/%s.%s", GetFileBaseName(fname), StrMakeUniqueName());
	fd_dst = FsCreate(d_name);
	if (!fd_dst)
	{
		FsClose(fd_src);
		return;
	}

	// 作業バッファを確保
	//--------------------
	tmp_buf = devMalloc(TMPBUF_LEN, "MakeBackupFile");

	len = FsGetSizeOrig(fd_src);
	while(len)
	{
		size = (len >= TMPBUF_LEN) ? TMPBUF_LEN : len;
		FsRead(fd_src, tmp_buf, size);
		FsWrite(fd_dst, tmp_buf, size);

		len -= size;
	}

	FsClose(fd_src);
	FsClose(fd_dst);

	Free(tmp_buf);

//	SYSINFODSP("Make Backup file");
//	SYSINFODSP("%s", MSG_FILE(d_name));
//	SYSINFO("Make Backup file");
//	SYSINFO("%s", MSG_FILE(d_name));
//	SYSINFOCNS("Make Backup file");
//	SYSINFOCNS("%s", MSG_FILE(d_name));
}

