
#include "co_file.h"
#include "co_memory.h"
#include "co_os.h"
#include "co_hash.h"
#include "co_strings.h"
#include "co_zlib.h"
#include "co_misc.h"


enum enmPATH_MODE {
	PATH_IMAGE,									// イメージ上のファイル名
	PATH_HOST,									// HOST 上のファイル名
};

#define SECTOR_SIZE  2048						// セクタサイズ

// malloc 関連
//-------------
#define fioMalloc(size, name)  MemMalloc(MEM_FS, size, name)

// イメージファイル情報
//----------------------
#define FILE_HEADER_SIZE  (4 + sizeof(int) * 2)		// ヘッダサイズ
#define FILE_INFO_SIZE  (FNAME_MAXLEN + (sizeof(int) * 2))
#define HEADER_CODE  "FPAK"						// ヘッダ文字列


struct _sFILE {
	BOOL	on_image;								// TRUE = イメージ上のファイル
	FILE   *fd;										// ファイルハンドル
	size_t	ofs;									// 先頭からのオフセット(イメージファイル用)
	size_t	size;									// ファイルサイズ(セクタサイズで切り上げ)
	size_t  size_orig;								// ファイル実サイズ(セクタサイズで切り上げていないサイズ)
	size_t  acc_pos;								// アクセス位置
};

typedef struct {
	int ofs;									// データ先頭からのオフセット
	int size;									// ファイルサイズ(セクタサイズで切り上げ)
	int size_orig;								// ファイル実サイズ
} sFileInfo;

typedef struct {
	char	   name[FNAME_MAXLEN];					// イメージファイルのファイル名
	sFILE	  *fp;									// イメージファイルのファイルハンドル
	sFileInfo *info;								// イメージファイル情報確報ワーク
	IHASH	  *hash;								// ハッシュハンドル
} sImage;


static int imageExist;							// TRUE = イメージファイルが指定されている
static sImage imageInfo;						// マウント情報


//==============================================================
static const char *l_makePath(int mode, const char *name)
//--------------------------------------------------------------
// パス名を変換する
//--------------------------------------------------------------
// in:	mode = 動作モード(enmPATH_MODE)
//		name = ファイル名
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	static char fname[FNAME_MAXLEN];

	if(mode == PATH_IMAGE)
	{
		// イメージ上のファイル名なら、そのまま返す
		return name;
	}

	// 最大長より長い場合はアサートで止める
	//--------------------------------------
	ASSERT(strlen(name) < (FNAME_MAXLEN - 2));

  char f[FNAME_MAXLEN];
	PATHCOPY(f, name);
  
	OsGetFileName(fname, f);				// ファイル名を機種依存仕様へ変換

	return fname;
}

//==============================================================
static sFILE *l_createHandle(void)
//--------------------------------------------------------------
// ファイルハンドルの取得
// ※必要なワークを初期化しておく
//--------------------------------------------------------------
// in:	なし
//--------------------------------------------------------------
// out:	ファイルハンドル
//==============================================================
{
	sFILE *fp;

	fp = (sFILE *)fioMalloc(sizeof(sFILE), "sFILE");
	ASSERT(fp);

	return fp;
}

//==============================================================
static void l_destroyHandle(sFILE *fp)
//--------------------------------------------------------------
// ファイルハンドルの破棄
//--------------------------------------------------------------
// in:	fp = ファイルハンドル
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	Free(fp);
}

//==============================================================
static size_t l_readFile(sFILE *fp, u_char *ptr, size_t size)
//--------------------------------------------------------------
// データ読み込み
//--------------------------------------------------------------
// in:	fp   = ファイルハンドル
//		ptr  = 読込先
//		size = サイズ
//--------------------------------------------------------------
// out:	読み込んだバイト数
//==============================================================
{
	size_t len;

	if(fp->on_image)
	{
		// イメージファイルからの同時オープンに対応する為、いちいちシークする
		fseek(fp->fd, (long)(fp->ofs + fp->acc_pos), SEEK_SET);
	}
	len = fread(ptr, 1, size, fp->fd);
	fp->acc_pos += len;

	return len;
}

//==============================================================
void FsInit(void)
//--------------------------------------------------------------
// 初期化
//--------------------------------------------------------------
// in:	なし
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	imageExist = FALSE;

	SYSINFO(".... file initialize");
}

//==============================================================
void FsFin(void)
//--------------------------------------------------------------
// 終了
//--------------------------------------------------------------
// in:	なし
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	FsUnMountImage();

	SYSINFO(".... file finish");
}

//==============================================================
void FsMountImage(const char *image)
//--------------------------------------------------------------
// イメージファイルのマウント
//--------------------------------------------------------------
// in:	image = イメージファイルの名前(NULL = イメージファイル無し)
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	sFILE *fp;
	char *top, *p;
	u_int flag;
	int num;
	int ofs, size, size_o;
	char header_code[4 + 1];
	IHASH *hash;
	HASH *ptr;
	sFileInfo *info;

	if(imageExist)
	{
		// 既にマウントされているファイルが有る場合は、アンマウントしておく
		//------------------------------------------------------------------
		FsUnMountImage();
	}

	if(image)
	{
		PATHCOPY(imageInfo.name, image);
		fp = FsOpen(imageInfo.name);
		if(fp)
		{
			u_int tmp_b;
			int h_size;

			// ヘッダサイズ判定
			//------------------
			FsRead(fp, &tmp_b, sizeof(u_int));
			h_size = ntohl(tmp_b);

			// ヘッダは圧縮されているので、読み込んで展開する
			//------------------------------------------------
			p = (char *)fioMalloc(h_size - 4, "fsTmp");
			ASSERT(p);
			FsRead(fp, p, h_size - 4);
			top = (char *)_ZlibDecode(p, ZlibEncodeSize(p), MEM_FS);
			ASSERT(top);
			Free(p);

			// ヘッダ判定
			//------------
			p = top;
			StrCopyLength(header_code, 4 + 1, p);
			if(strcmp(header_code, HEADER_CODE) != 0)
			{
				ASSERT(0);
			}
			p += 4;

			flag = ntohl(*(u_int *)p);		// パック情報
			p += sizeof(u_int);
			num = ntohl(*(u_int *)p);		// ファイル数
			p += sizeof(u_int);

			hash = OpenHash(num);				// ハッシュを開く
			ASSERT(hash);

			info = (sFileInfo *)fioMalloc(sizeof(sFileInfo) * num, "sFileInfo");
			ASSERT(info);
			imageInfo.info = info;

			while(num)
			{
				ptr = InstallString(hash, p);
				ASSERT(ptr);
				p += FNAME_MAXLEN;
				ofs = ntohl(*(u_int *)p);			// ファイル先頭からのオフセット
				p += sizeof(u_int);
				size_o = ntohl(*(u_int *)p);		// 実ファイルサイズ
				p += sizeof(u_int);
				size = ntohl(*(u_int *)p);			// ファイルサイズ(セクタ単位で切り上げ)

				ptr->p = info;
				info->ofs = ofs + h_size;			// データを格納(ここでヘッダサイズを加える)
				info->size = size;
				info->size_orig = size_o;
				info += 1;

				p += (FILE_INFO_SIZE - (FNAME_MAXLEN + 4));
				num--;
			}
			Free(top);

			imageInfo.fp = fp;					// 以後ファイルは開いたままになります…
			imageInfo.hash = hash;

			imageExist = TRUE;

			PRINTF("mount '%s'\n", imageInfo.name);
		}
	}
}

//==============================================================
void FsUnMountImage(void)
//--------------------------------------------------------------
// イメージファイルのアンマウント
//--------------------------------------------------------------
// in:	なし
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	if(imageExist)
	{
		FsClose(imageInfo.fp);
		CloseHash(imageInfo.hash);
		Free(imageInfo.info);

		PRINTF("unmount %s\n", imageInfo.name);

		imageExist = FALSE;
	}
}

//==============================================================
sFILE *FsOpen(const char *name)
//--------------------------------------------------------------
// ファイルオープン
//--------------------------------------------------------------
// in:	name = ファイル名
//--------------------------------------------------------------
// out:	ファイルハンドル(NULL = エラー)
//==============================================================
{
	sFILE *fp;
	FILE *fd;
	int len;
	HASH *hp;

	if(imageExist)
	{
		// イメージファイル上のファイルを開く
		//------------------------------------
		hp = LookupString(imageInfo.hash, name);
		if(hp)
		{
			sFileInfo *info;

			fp = l_createHandle();				// ハンドル取得
			fp->fd = imageInfo.fp->fd;
			fp->on_image = TRUE;

			info = (sFileInfo *)hp->p;
			fp->ofs = info->ofs;
			fp->size = info->size;
			fp->size_orig = info->size_orig;
			fp->acc_pos = 0;
			fseek(fp->fd, info->ofs, SEEK_SET);

			PRINTF("open from image '%s'\n", name);

			return fp;
		}
		else
		{
			// イメージ上に見つからなかった場合
			//----------------------------------
			PRINTF("No file on image '%s'\n", name);
		}
	}

	//---------------------------------------------------------
	// HOST 上のファイルを開く(イメージ上になかった場合に適用)
	//---------------------------------------------------------
	fd = fopen(l_makePath(PATH_HOST, name), "rb");
	if(fd)
	{
		fp = l_createHandle();					// ハンドル取得
		fp->fd = fd;
		fp->on_image = FALSE;

		fseek(fd, 0, SEEK_END);					// いきなりファイルサイズを求めておく
		len = ftell(fd);						// バイナリモードの場合、fseek() でサイズが返ってこない…
		fp->size = ceilingvalue(len, SECTOR_SIZE);
		fp->size_orig = len;					// 実サイズ
		fp->acc_pos = 0;

		fseek(fd, 0, SEEK_SET);					// ファイルポインタは戻しておく
	}
	else
	{
		fp = NULL;
	}

	return fp;
}

//==============================================================
void FsClose(sFILE *fp)
//--------------------------------------------------------------
// ファイルクローズ
//--------------------------------------------------------------
// in:	fp = ファイルハンドル
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	if(!fp->on_image)
	{
		// 直接開いたファイル
		//--------------------
		fclose(fp->fd);
	}

	l_destroyHandle(fp);
}

//==============================================================
size_t FsRead(sFILE *fp, void *ptr, size_t size)
//--------------------------------------------------------------
// ファイル読み込み
//--------------------------------------------------------------
// in:	fp   = ファイルハンドル
//		ptr  = 読込先ポインタ
//		size = 読み込みサイズ
//--------------------------------------------------------------
// out:	読み込んだサイズ
//==============================================================
{
	size_t len;

	len = l_readFile(fp, (u_char *)ptr, size);
//	ASSERT(len == size);

	return len;
}

//==============================================================
size_t FsSeek(sFILE *fp, size_t ofs, int whence)
//--------------------------------------------------------------
// ファイルシーク
//--------------------------------------------------------------
// in:	fp     = ファイルハンドル
//		ofs    = オフセット
//		whence = モード
//				 SEEK_SET: ファイルの先頭から
//				 SEEK_CUR: 現在位置から
//				 SEEK_END: ファイルの終端から
//--------------------------------------------------------------
// out:	0 = 成功
//==============================================================
{
	int ret = -1;

	if(fp->on_image)
	{
		// イメージ上のファイル
		// TODO: エラーチェックを強化しとく
		//----------------------------------
		switch(whence)
		{
			case SEEK_SET:
			{
				fp->acc_pos = ofs;
			}
			break;

			case SEEK_CUR:
			{
				fp->acc_pos += ofs;
			}
			break;

			case SEEK_END:
			{
				fp->acc_pos = fp->size_orig - ofs;
			}
			break;
		}
		ret = 0;
	}
	else
	{
		// 直接開いたファイル
		//--------------------
		ret = fseek(fp->fd, (long)ofs, whence);
	}

	return ret;
}

//==============================================================
size_t FsTell(sFILE *fp)
//--------------------------------------------------------------
// ファイルの読み込み位置を取得
//--------------------------------------------------------------
// in:	fp = ファイルハンドル
//--------------------------------------------------------------
// out:	読み込み位置
//==============================================================
{
	return fp->acc_pos;
}

//==============================================================
size_t FsGetSize(sFILE *fp)
//--------------------------------------------------------------
// ファイルサイズの取得
// ※セクタサイズに切り上げた値です
// ※FsCreate() で開いたファイルの場合は、実サイズを返します
//--------------------------------------------------------------
// in:	fp = ファイルハンドル
//--------------------------------------------------------------
// out:	ファイルサイズ
//==============================================================
{
	return fp->size;
}

//==============================================================
size_t FsGetSizeOrig(sFILE *fp)
//--------------------------------------------------------------
// 実ファイルサイズの取得
// ※セクタサイズに切り上げていない値
//--------------------------------------------------------------
// in:	fp = ファイルハンドル
//--------------------------------------------------------------
// out:	ファイルサイズ
//==============================================================
{
	return fp->size_orig;
}

//==============================================================
size_t FsGetFileSize(const char *name)
//--------------------------------------------------------------
// ファイルサイズの取得
// ※ファイル名から取得
//--------------------------------------------------------------
// in:	name = ファイル名
//--------------------------------------------------------------
// out:	ファイルサイズ
//==============================================================
{
	sFILE *fp;
	size_t size = 0;

	fp = FsOpen(name);
	ASSERT(fp);
	if(fp)
	{
		size = FsGetSize(fp);
		FsClose(fp);
	}

	return size;
}

//==============================================================
size_t FsGetFileSizeOrig(const char *name)
//--------------------------------------------------------------
// 実ファイルサイズの取得
// ※ファイル名から取得
//--------------------------------------------------------------
// in:	name = ファイル名
//--------------------------------------------------------------
// out:	ファイルサイズ
//==============================================================
{
	sFILE *fp;
	size_t size = 0;

	fp = FsOpen(name);
	ASSERT(fp);
	if(fp)
	{
		size = FsGetSizeOrig(fp);
		FsClose(fp);
	}

	return size;
}

//==============================================================
sFILE *FsCreate(const char *name)
//--------------------------------------------------------------
// ファイルを新規作成する
//--------------------------------------------------------------
// in:	name = ファイル名
//--------------------------------------------------------------
// out:	ファイルハンドル(NULL = エラー)
//==============================================================
{
	sFILE *fp;
	FILE *fd;

	if(imageExist)
	{
		if(LookupString(imageInfo.hash, name))
		{
			// イメージ上に存在する場合は、エラーとして扱う
			PRINTF("File '%s' already exists.\n", name);
			return NULL;
		}
	}

	fd = fopen(l_makePath(PATH_HOST, name), "wb");
//	ASSERT(fd);

	if(fd)
	{
		fp = l_createHandle();
		fp->fd = fd;
		fp->on_image = FALSE;
		fp->size = fp->size_orig = 0;
	}
	else
	{
		// エラー
		//--------
		fp = NULL;
	}

	return fp;
}

//==============================================================
void FsWrite(sFILE *fp, void *ptr, size_t size)
//--------------------------------------------------------------
// データをファイルに書き出す
//--------------------------------------------------------------
// in:	fp   = ファイルハンドル
//		ptr  = データポインタ
//		size = データサイズ
//--------------------------------------------------------------
// out:	なし
//==============================================================
{
	size_t len;

	if(fp->on_image)
	{
		PRINTF("File on image.\n");
	}
	else
	{
		len = fwrite(ptr, size, 1, fp->fd);
		if(len >= 0)
		{
			fp->size += len;
			fp->size_orig = fp->size;
		}
		ASSERT(len >= 0);
	}
}

